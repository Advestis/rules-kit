<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ruleskit.rule API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ruleskit.rule</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import inspect
from abc import ABC
import pandas as pd
import numpy as np
from typing import Optional, Union, Tuple
from time import time
from pathlib import Path
from .condition import Condition
from .activation import Activation
from .utils import rfunctions as functions
from .thresholds import Thresholds
import logging

from .utils.rfunctions import calc_zscore_external

logger = logging.getLogger(__name__)


class Rule(ABC):

    &#34;&#34;&#34;An abstract Rule object.

    A Rule is a condition (represented by any daughter class of ruleskit.Condition), applied on real features and target
    data.
    The Rule contains, in addition to the Condition object, many attributes dependent on the features data, such as
    the activation vector (a 1-D np.ndarray with 0 when the rule is activated - condition is met - and 0 when it is not)
    but also the rule&#39;s prediction (computed in the daughter class).

    Daughter classes can remember more attributes (precision, user-definded criterion...).

    Rule also include metrics that can be used for profiling the code : it will remember the time taken to fit the rule
    (fitting is the computation of the rule&#39;s attribute from the condition and the features data), the time taken
    to compute the activation vector and the time taken to make a prediction.

    To compute those metrics, one must use the rule&#39;s &#34;fit&#34; methods. Once this is done, one cas use the &#34;predict&#34;
     methods on a different set of features data.

    The Rule object can access any attribute of its condition as if it was its own : rule.features_indexes will return
    the features_indexes attribute&#39;s value of the condition in the Rule object. See Condition class for more details.

    The Rule object can also access any attribute of its activation vector as if it was its own. See Activation class
    for more details.
    &#34;&#34;&#34;

    LOCAL_ACTIVATION = True
    THRESHOLDS = None
    &#34;&#34;&#34;Thresholds that the Rule must meet to be good. See `ruleskit.thresholds.Thresholds` for more details.&#34;&#34;&#34;

    condition_index = [&#34;features_names&#34;, &#34;features_indexes&#34;, &#34;bmins&#34;, &#34;bmaxs&#34;]
    rule_index = [&#34;prediction&#34;]
    index = condition_index + rule_index

    attributes_from_test_set = [&#34;test_set_size&#34;]
    attributes_from_train_set = [&#34;train_set_size&#34;]

    fitted_if_has = &#34;prediction&#34;

    daughters = []

    # noinspection PyUnresolvedReferences
    @classmethod
    def SET_THRESHOLDS(cls, path: Union[str, Path, &#34;TransparentPath&#34;, None], show=False):
        &#34;&#34;&#34;Set thresholds globally for all futur Rules&#34;&#34;&#34;
        if path is None:
            cls.THRESHOLDS = None
        else:
            cls.THRESHOLDS = Thresholds(path, show)

    def __init__(
        self,
        condition: Optional[Condition] = None,
        activation: Optional[Activation] = None,
    ):

        if condition is not None and not isinstance(condition, Condition):
            raise TypeError(&#34;Argument &#39;condition&#39; must derive from Condition or be None.&#34;)
        if activation is not None and not isinstance(activation, Activation):
            raise TypeError(&#34;Argument &#39;activation&#39; must derive from Activation or be None.&#34;)
        if activation is not None and condition is None:
            raise ValueError(&#34;Condition can not be None if activation is not None&#34;)

        self._condition: Optional[Condition] = condition
        self._activation: Optional[Activation] = activation
        self._thresholds: Optional[Thresholds] = self.__class__.THRESHOLDS
        self._good: bool = True
        self._bad_because: Optional[str] = None

        self._coverage: Optional[float] = None
        self._prediction: Optional[Union[float, str, int]] = None
        self._criterion: Optional[float] = None
        self._zscore: Optional[float] = None

        self._time_fit: float = -1
        self._time_eval: float = -1
        self._time_calc_activation: float = -1
        self._time_predict: float = -1
        self._time_calc_prediction: float = -1
        self._time_calc_criterion: float = -1
        self._time_calc_zscore: float = -1
        self._fitted: bool = False
        self._evaluated = False
        self._train_set_size: Optional[int] = None
        self._test_set_size: Optional[int] = None
        if self._activation is not None:
            self.check_thresholds(&#34;coverage&#34;)

    # noinspection PyUnresolvedReferences
    def set_thresholds(self, path: Union[str, Path, &#34;TransparentPath&#34;], show=False):
        &#34;&#34;&#34;Set thresholds for this rule only&#34;&#34;&#34;
        if path is None:
            self._thresholds.THRESHOLDS = None
        else:
            self._thresholds = Thresholds(path, show)

    def check_thresholds(self, attribute: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;If `ruleskit.rule.Rule.THRESHOLDS` is specified, will check that this rule is good regarding those
        thresholds, and set the flags *good* and *bad_because* accordingly

        Parameters
        ----------
        attribute: Optional[str]
            If specified, will only check the threshold of this rule attribute. If not, will test every rule attributes
            for which a threshold is defined.
        &#34;&#34;&#34;

        if self.__class__.THRESHOLDS is None:
            return

        if attribute is not None:
            if not self.__class__.THRESHOLDS(attribute, self):
                self._bad_because = attribute
                self._good = False
            return

        for attribute in dir(self):
            if attribute.startswith(&#34;__&#34;):
                continue
            if not self.__class__.THRESHOLDS(attribute, self):
                self._bad_because = attribute
                self._good = False
                return
        logger.debug(f&#34;Rule {self} is good&#34;)

    def __and__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        &#34;&#34;&#34;Logical AND (&amp;) of two rules. It is simply the logical AND of the two rule&#39;s conditions and activations.&#34;&#34;&#34;
        condition = self._condition &amp; other._condition
        activation = self._activation &amp; other._activation
        return self.__class__(condition, activation)

    def __add__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        return NotImplemented(&#34;Can not add rules (seen as &#39;logical OR&#39;). You can use logical AND however.&#34;)

    # def __del__(self):
    #     self.del_activation()

    def del_activation(self):
        &#34;&#34;&#34;Deletes the activation vector&#39;s data, but not the object itself, so any computed attributes will remain
        available&#34;&#34;&#34;
        if hasattr(self, &#34;_activation&#34;) and self._activation is not None:
            self._activation.delete()

    @property
    def activation_available(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the rule has an activation vector, and if this Activation&#39;s object data is available.&#34;&#34;&#34;
        if self._activation is None:
            return False
        if self._activation.data_format == &#34;file&#34;:
            return self._activation.data.is_file()
        else:
            return self._activation.data is not None

    @property
    def coverage(self) -&gt; float:
        if self._activation is not None:
            self._coverage = self._activation.coverage
            return self._activation.coverage
        return self._coverage

    @coverage.setter
    def coverage(self, value: Union[int, None]):
        if self._activation is not None:
            self._activation._coverage = value
        self._coverage = value

    @property
    def train_set_size(self) -&gt; int:
        return self._train_set_size

    @property
    def test_set_size(self) -&gt; int:
        return self._test_set_size

    @train_set_size.setter
    def train_set_size(self, value: Union[int, None]):
        self._train_set_size = value

    @test_set_size.setter
    def test_set_size(self, value: Union[int, None]):
        self._test_set_size = value

    @property
    def condition(self) -&gt; Condition:
        return self._condition

    @property
    def activation(self) -&gt; Union[None, np.ndarray]:
        &#34;&#34;&#34;Returns the Activation vector&#39;s data in a form of a 1-D np.ndarray, or None if not available.

        Returns
        -------
        np.ndarray
            of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, ...]
        &#34;&#34;&#34;
        if self._activation:
            return self._activation.raw
        return None

    @property
    def prediction(self) -&gt; Union[str, float]:
        return self._prediction

    @property
    def thresholds(self) -&gt; Thresholds:
        return self._thresholds

    @property
    def good(self) -&gt; bool:
        return self._good

    @property
    def bad_because(self) -&gt; str:
        return self._bad_because

    @property
    def time_fit(self) -&gt; float:
        &#34;&#34;&#34;Profiling attribute. Time in seconds taken to fit the rule&#34;&#34;&#34;
        return self._time_fit

    @property
    def time_predict(self) -&gt; float:
        &#34;&#34;&#34;Profiling attribute. Time in seconds taken by the rule to make a prediction&#34;&#34;&#34;
        return self._time_predict

    @property
    def time_calc_activation(self) -&gt; float:
        &#34;&#34;&#34;Profiling attribute. Time in seconds taken to comptue the activation vector&#34;&#34;&#34;
        return self._time_calc_activation

    def __getattr__(self, item):
        &#34;&#34;&#34;If item is not found in self, try to fetch it from its activation or condition.&#34;&#34;&#34;
        if item == &#34;_activation&#34; or item == &#34;_condition&#34;:
            raise AttributeError(f&#34;&#39;Rule&#39; object has no attribute &#39;{item}&#39;.&#34;)

        if hasattr(self._activation, item):
            return getattr(self._activation, item)
        if hasattr(self._condition, item):
            return getattr(self._condition, item)
        raise AttributeError(f&#34;&#39;Rule&#39; object has no attribute &#39;{item}&#39;.&#34;)

    def __setattr__(self, item, value):
        &#34;&#34;&#34;If item is private (starts with _), then default behavior. Else, if the item is not yet known by the rule
        but is known by its condition or activation, will set it to the condition or the activation. Else,
        raises AttributeError.&#34;&#34;&#34;
        if item.startswith(&#34;_&#34;):
            super(Rule, self).__setattr__(item, value)
            return
        if not hasattr(self, item):
            if hasattr(self._activation, item):
                setattr(self._activation, item, value)
            elif hasattr(self._condition, item):
                setattr(self._condition, item, value)
            else:
                raise AttributeError(f&#34;Can not set attribute &#39;{item}&#39; in object Rule.&#34;)
        else:
            super(Rule, self).__setattr__(item, value)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Two rules are equal if their conditions are equal.&#34;&#34;&#34;
        if not isinstance(other, Rule):
            return False
        else:
            return self._condition == other._condition

    def __contains__(self, other: &#34;Rule&#34;) -&gt; bool:
        &#34;&#34;&#34;
        A Rule contains another Rule if the second rule&#39;s activated points are also all activated by the first
        rule.
        &#34;&#34;&#34;
        if not self._activation or not other._activation:
            return False
        return other._activation in self._activation

    def __str__(self) -&gt; str:
        prediction = &#34;&lt;prediction unset&gt;&#34;
        if self._prediction is not None:
            prediction = self._prediction
        if self._condition is None:
            return &#34;empty rule&#34;
        return f&#34;If {self._condition.__str__()} Then {prediction}.&#34;

    @property
    def to_hash(self) -&gt; Tuple[str]:
        return (&#34;r&#34;,) + self._condition.to_hash[1:]

    def __hash__(self) -&gt; hash:
        return hash(frozenset(self.to_hash))

    def __len__(self):
        &#34;&#34;&#34;A Rule&#39;s length is the number of features it talks about&#34;&#34;&#34;
        return len(self._condition)

    def evaluate_activation(self, xs: Union[pd.DataFrame, np.ndarray]) -&gt; Activation:
        &#34;&#34;&#34;Computes and returns the activation vector from an array of features.

        Parameters
        ----------
        xs: Union[pd:DataFrame, np.ndarray]
            The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
            or pd:DataFrame.

        Returns
        -------
        Activation
        &#34;&#34;&#34;
        arr = self._condition.evaluate(xs)
        # noinspection PyTypeChecker
        a = Activation(arr, to_file=self.__class__.LOCAL_ACTIVATION)
        return a

    def fit(
        self,
        y: Union[np.ndarray, pd.Series],
        xs: Optional[Union[pd.DataFrame, np.ndarray]] = None,
        force_if_not_good: bool = False,
        **kwargs
    ):
        &#34;&#34;&#34;Computes activation and attributes relevant to the train set

        Parameters
        ----------
        y: Union[np.ndarray, pd.Series]
        xs: Union[pd.DataFrame, np.ndarray]
        force_if_not_good: bool
        kwargs: dict
            Additionnal keyword arguments for calc_&lt;any_attribute&gt;
        &#34;&#34;&#34;

        if &#34;method&#34; in kwargs:
            raise IndexError(&#34;Key &#39;method&#39; can not be given to &#39;fit&#39;&#34;)

        if self._fitted and xs is None:
            return

        t0 = time()

        def launch_method(method, **kw):
            expected_args = list(inspect.signature(method).parameters)
            if &#34;kwargs&#34; not in expected_args:
                kw = {item: kw[item] for item in kw if item in expected_args}
            method(**kw)

        if xs is not None and len(xs) == 0:
            logger.warning(&#34;Given xs is empty&#34;)
            return

        self.calc_activation(xs=xs)

        for attr in self.__class__.attributes_from_train_set:
            if attr == &#34;activation&#34;:
                raise ValueError(&#34;&#39;activation&#39; can not be specified in &#39;attributes_from_train_set&#39;&#34;)
            if not self.good and not force_if_not_good:
                setattr(self, f&#34;_{attr}&#34;, np.nan)
                continue
            launch_method(getattr(self, f&#34;calc_{attr}&#34;), y=y, xs=xs, **kwargs)
            if self.good:
                self.check_thresholds(attr)

        if self.good:
            self.check_thresholds()
        self.trigger_subattributes_computation()
        self._time_fit = time() - t0
        self._fitted = True

    def eval(
        self,
        y: Union[np.ndarray, pd.Series],
        xs: Optional[Union[pd.DataFrame, np.ndarray]] = None,
        recompute_activation: bool = False,
        force_if_not_good: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;Computes prediction, standard deviation, and regression criterion

        Parameters
        ----------
        y: Union[np.ndarray, pd.Series]
        xs: Union[pd.DataFrame, np.ndarray]
        recompute_activation: bool
            To reset self.activation using the given xs
        force_if_not_good: bool
            If the rule was seen as &#34;bad&#34;, eval will not trigger unless this boolean is True (Default value = False)
        kwargs
            Additionnal keyword arguments for calc_&lt;any_attribute&gt;
        &#34;&#34;&#34;

        if &#34;method&#34; in kwargs:
            raise IndexError(&#34;Key &#39;method&#39; can not be given to &#39;eval&#39;&#34;)

        t0 = time()

        if not self.good and not force_if_not_good:
            self._time_eval = time() - t0
            self._fitted = True
            for attr in self.__class__.attributes_from_test_set:
                setattr(self, f&#34;_{attr}&#34;, np.nan)
            return

        def launch_method(method, **kw):
            expected_args = list(inspect.signature(method).parameters)
            if &#34;kwargs&#34; not in expected_args:
                kw = {item: kw[item] for item in kw if item in expected_args}
            method(**kw)

        if xs is not None and len(xs) == 0:
            logger.warning(&#34;Given xs is empty&#34;)
            return

        if recompute_activation:
            self.calc_activation(xs=xs)
            xs = None

        if not self.activation_available:
            raise ValueError(
                &#34;Must have fitted the rule before calling &#39;eval&#39;, or use &#39;recompute_activation=True&#39; to recompute it&#34;
                &#34; from given xs&#34;
            )

        if xs is not None:
            activation = self.evaluate_activation(xs)
        else:
            activation = self._activation

        for attr in self.__class__.attributes_from_test_set:
            if attr == &#34;activation&#34;:
                raise ValueError(&#34;&#39;activation&#39; can not be specified in &#39;attributes_from_test_set&#39;&#34;)
            if not self.good and not force_if_not_good:
                setattr(self, f&#34;_{attr}&#34;, np.nan)
                continue
            launch_method(getattr(self, f&#34;calc_{attr}&#34;), y=y, xs=xs, activation=activation, **kwargs)
            if self.good:
                self.check_thresholds(attr)

        if self.good:
            self.check_thresholds()
        self._time_eval = time() - t0
        self._evaluated = True

    def trigger_subattributes_computation(self):
        &#34;&#34;&#34;Uses getattr(self, attr) to trigger important attributes computation. Important attributes should be
        Ruleset.rule_index&#34;&#34;&#34;
        for attr in self.__class__.index:
            _ = getattr(self, attr)

    def calc_prediction_vector(self, activation: Optional[np.ndarray] = None) -&gt; Union[None, pd.Series]:
        if activation is None:
            activation = self.activation
        if activation is None:
            return None
        if self.prediction is None:
            return pd.Series(np.nan * activation)
        if len(self) == 0:
            return pd.Series(dtype=int)
        if isinstance(self.prediction, str):
            pred = pd.Series(np.where(activation == 0, np.nan, activation))
            pred[pred == 1] = self.prediction
            return pred
        else:
            # noinspection PyUnresolvedReferences
            return self.prediction * pd.Series(np.where(activation == 0, np.nan, activation))

    def predict(self, xs: Optional[Union[pd.DataFrame, np.ndarray]] = None) -&gt; Union[np.ndarray, pd.Series]:
        &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
        Will raise ValueError is xs is None and activation is not yet known.

        Parameters
        ----------
        xs: Optional[Union[pd.DataFrame, np.ndarray]]
            The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
            or pd:DataFrame. If not specified the rule&#39;s activation vector must have been computed already.

        Returns
        -------
        Union[np.ndarray, pd.Series]
            np.nan where rule is not activated, rule&#39;s prediction where it is. If xs vas given and it was a dataframe,
            return a pd.Series. Else, a np.ndarray.
        &#34;&#34;&#34;
        t0 = time()
        if xs is not None:
            act = self.evaluate_activation(xs).raw
        elif self.activation is None:
            raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
        else:
            act = self.activation
        to_ret = np.array([np.nan] * len(act))
        if isinstance(self.prediction, str):
            if self.prediction == &#34;nan&#34;:
                raise ValueError(
                    &#34;Prediction should not be the &#39;nan&#39; string, it will conflict with NaNs. Rename your class.&#34;
                )
            to_ret = to_ret.astype(str)
        to_ret[act == 1] = self.prediction
        if xs is not None and not isinstance(xs, np.ndarray):
            to_ret = xs.__class__(index=xs.index, data=to_ret).squeeze()  # So not to requier pandas explicitly
        self._time_predict = time() - t0
        return to_ret

    def get_correlation(self, other: &#34;Rule&#34;) -&gt; float:
        &#34;&#34;&#34;Computes the correlation between self and other
        Correlation is the number of points in common between the two vectors divided by their length, times the product
        of the rules&#39; signs.
        Both vectors must have the same length.
        &#34;&#34;&#34;
        if not len(self) == len(other):
            raise ValueError(&#34;Both vectors must have the same length&#34;)

        sign = (self.prediction / abs(self.prediction)) * (other.prediction / abs(other.prediction))
        return self._activation.get_correlation(other._activation) * sign

    def calc_activation(self, xs: Optional[Union[pd.DataFrame, np.ndarray]] = None):
        &#34;&#34;&#34;Uses self.evaluate to set self._activation.

        Parameters
        ----------
        xs: Union[pd.DataFrame, np.ndarray, None]
            The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
            or pd:DataFrame.
        &#34;&#34;&#34;
        if xs is None:
            if self._activation is None:
                raise ValueError(
                    &#34;If calling calc_activation without specifying xs, activation must have been computed already.&#34;
                )
            return
        t0 = time()

        if len(xs) == 0:
            logger.warning(&#34;Given xs is empty&#34;)
            return
        self._activation = self.evaluate_activation(xs)
        self._time_calc_activation = time() - t0
        self.check_thresholds(&#34;coverage&#34;)

    def calc_train_set_size(self, y: Union[np.ndarray, pd.Series]):
        if isinstance(y, (pd.Series, pd.DataFrame)):
            self.train_set_size = len(y.index)
        else:
            self.train_set_size = len(y)

    def calc_test_set_size(self, y: Union[np.ndarray, pd.Series]):
        if isinstance(y, (pd.Series, pd.DataFrame)):
            self.test_set_size = len(y.index)
        else:
            self.test_set_size = len(y)


class RegressionRule(Rule):
    &#34;&#34;&#34;Rule applied on continuous target data.&#34;&#34;&#34;

    rule_index = Rule.rule_index + [&#34;coverage&#34;, &#34;zscore&#34;, &#34;criterion&#34;, &#34;std&#34;]
    index = Rule.condition_index + rule_index
    attributes_from_train_set = Rule.attributes_from_train_set + [&#34;prediction&#34;, &#34;std&#34;, &#34;sign&#34;, &#34;zscore&#34;]
    attributes_from_test_set = [&#34;criterion&#34;]

    def __init__(
        self,
        condition: Optional[Condition] = None,
        activation: Optional[Activation] = None,
    ):
        super().__init__(condition, activation)
        self._std = None
        self._sign = None

        # Inspection / Audit attributs
        self._time_calc_std = -1

    @property
    def std(self) -&gt; float:
        return self._std

    @property
    def sign(self) -&gt; str:
        return self._sign

    @property
    def criterion(self) -&gt; float:
        # noinspection PyTypeChecker
        return self._criterion

    @property
    def zscore(self) -&gt; float:
        return self._zscore

    @property
    def time_calc_prediction(self) -&gt; float:
        return self._time_calc_prediction

    @property
    def time_calc_criterion(self) -&gt; float:
        return self._time_calc_criterion

    @property
    def time_calc_std(self) -&gt; float:
        return self._time_calc_std

    def calc_prediction(self, y: [np.ndarray, pd.Series], activation: Optional[Activation] = None):
        &#34;&#34;&#34;Computes the mean of all activated points in target y and use it as prediction

        Parameters
        ----------
        y: [np.ndarray, pd.Series]
            The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
            or pd.Series
        activation: Optional[Activation]
            If specified, uses this activation instead of self.activation
        &#34;&#34;&#34;
        t0 = time()
        if activation is None:
            activation = self._activation
            if activation is None:
                return None
        if not isinstance(activation, Activation):
            raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
        activation = activation.raw
        self._prediction = functions.conditional_mean(activation, y)
        self._time_calc_prediction = time() - t0
        self.check_thresholds(&#34;prediction&#34;)

    def calc_sign(self):
        if self._prediction is None:
            return
        if self._prediction &lt; 0:
            self._sign = &#34;-&#34;
        else:
            self._sign = &#34;+&#34;

    def calc_std(self, y: Union[np.ndarray, pd.Series], activation: Optional[Activation] = None):
        &#34;&#34;&#34;Computes the standard deviation of all activated points in target y

        Parameters
        ----------
        y: Union[np.ndarray, pd.Series]
            The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
            or pd.Series.
        activation: Optional[Activation]
            If specified, uses this activation instead of self.activation
        &#34;&#34;&#34;
        t0 = time()
        if activation is None:
            activation = self._activation
            if activation is None:
                return None
        if not isinstance(activation, Activation):
            raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
        activation = activation.raw
        self._std = functions.conditional_std(activation, y)
        self._time_calc_std = time() - t0
        self.check_thresholds(&#34;std&#34;)

    def calc_criterion(
            self,
            y: Union[np.ndarray, pd.Series],
            activation: Optional[Activation] = None,
            **kwargs
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        y: Union[np.ndarray, pd.Series]
            The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
            or pd.Series.
        activation: Optional[Activation]
            If specified, uses this activation instead of self.activation
        kwargs: dict
            Arguments for calc_regression_criterion
        &#34;&#34;&#34;
        t0 = time()
        if activation is None:
            activation = self._activation
            if activation is None:
                return None
        if not isinstance(activation, Activation):
            raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
        activation = activation.raw
        self._criterion = functions.calc_regression_criterion(
            self.calc_prediction_vector(activation=activation), y, **kwargs
        )
        self._time_calc_criterion = time() - t0
        self.check_thresholds(&#34;criterion&#34;)

    def calc_zscore(self, y: np.ndarray, activation: Optional[Activation] = None, horizon: int = 1):
        t0 = time()
        if activation is None:
            activation = self._activation
            if activation is None:
                return
        if not isinstance(activation, Activation):
            raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
        self._zscore = calc_zscore_external(
            prediction=self.prediction, nones=activation.nones, y=y, horizon=horizon
        )
        self.check_thresholds(&#34;zscore&#34;)
        self._time_calc_zscore = time() - t0


class ClassificationRule(Rule):
    &#34;&#34;&#34;Rule applied on discret target data.&#34;&#34;&#34;

    rule_index = Rule.rule_index + [&#34;coverage&#34;, &#34;criterion&#34;]
    index = Rule.condition_index + rule_index
    attributes_from_train_set = Rule.attributes_from_train_set + [&#34;prediction&#34;]
    attributes_from_test_set = [&#34;criterion&#34;]

    @property
    def prediction(self) -&gt; Union[int, float, str, np.integer, np.float64, None]:
        &#34;&#34;&#34;Returns the rule prediction. If rule was fitted alone, the self._prediction should be a np.ndarray
        containing the probability of each class. In that case, the most probable class is returned. If the rule was
        fitted in a stacked fit, then the prediction is already the most probable class and it is just returned.&#34;&#34;&#34;
        if self._prediction is not None:
            if isinstance(self._prediction, (float, int, str, np.integer, np.float64)):
                return self._prediction
            prop = [p[1] for p in self._prediction]
            idx = prop.index(max(prop))
            return self._prediction[idx][0]
        else:
            return None

    @property
    def criterion(self) -&gt; float:
        return self._criterion

    def calc_prediction(self, y: [np.ndarray, pd.Series]):
        &#34;&#34;&#34;
        Parameters
        ----------
        y: [np.ndarray, pd.Series]
            The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
            or pd.Series.
        &#34;&#34;&#34;
        t0 = time()
        if self.activation is None:
            raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
        self._prediction = functions.class_probabilities(self.activation, y)
        self._time_calc_prediction = time() - t0
        self.check_thresholds(&#34;prediction&#34;)

    def calc_criterion(
            self,
            y: Union[np.ndarray, pd.Series],
            activation: Optional[Activation] = None,
            **kwargs
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        y: Union[np.ndarray, pd.Series]
            The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
            or pd.Series
        activation: Optional[Activation]
            If specified, uses this activation instead of self.activation
        kwargs: dict
            Arguments for calc_classification_criterion
        &#34;&#34;&#34;
        t0 = time()
        if activation is None:
            activation = self._activation
            if activation is None:
                return None
        if not isinstance(activation, Activation):
            raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
        activation = activation.raw
        self._criterion = functions.calc_classification_criterion(activation, self.prediction, y, **kwargs)
        self._time_calc_criterion = time() - t0
        self.check_thresholds(&#34;criterion&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ruleskit.rule.ClassificationRule"><code class="flex name class">
<span>class <span class="ident">ClassificationRule</span></span>
<span>(</span><span>condition: Optional[<a title="ruleskit.condition.Condition" href="condition.html#ruleskit.condition.Condition">Condition</a>] = None, activation: Optional[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Rule applied on discret target data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClassificationRule(Rule):
    &#34;&#34;&#34;Rule applied on discret target data.&#34;&#34;&#34;

    rule_index = Rule.rule_index + [&#34;coverage&#34;, &#34;criterion&#34;]
    index = Rule.condition_index + rule_index
    attributes_from_train_set = Rule.attributes_from_train_set + [&#34;prediction&#34;]
    attributes_from_test_set = [&#34;criterion&#34;]

    @property
    def prediction(self) -&gt; Union[int, float, str, np.integer, np.float64, None]:
        &#34;&#34;&#34;Returns the rule prediction. If rule was fitted alone, the self._prediction should be a np.ndarray
        containing the probability of each class. In that case, the most probable class is returned. If the rule was
        fitted in a stacked fit, then the prediction is already the most probable class and it is just returned.&#34;&#34;&#34;
        if self._prediction is not None:
            if isinstance(self._prediction, (float, int, str, np.integer, np.float64)):
                return self._prediction
            prop = [p[1] for p in self._prediction]
            idx = prop.index(max(prop))
            return self._prediction[idx][0]
        else:
            return None

    @property
    def criterion(self) -&gt; float:
        return self._criterion

    def calc_prediction(self, y: [np.ndarray, pd.Series]):
        &#34;&#34;&#34;
        Parameters
        ----------
        y: [np.ndarray, pd.Series]
            The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
            or pd.Series.
        &#34;&#34;&#34;
        t0 = time()
        if self.activation is None:
            raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
        self._prediction = functions.class_probabilities(self.activation, y)
        self._time_calc_prediction = time() - t0
        self.check_thresholds(&#34;prediction&#34;)

    def calc_criterion(
            self,
            y: Union[np.ndarray, pd.Series],
            activation: Optional[Activation] = None,
            **kwargs
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        y: Union[np.ndarray, pd.Series]
            The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
            or pd.Series
        activation: Optional[Activation]
            If specified, uses this activation instead of self.activation
        kwargs: dict
            Arguments for calc_classification_criterion
        &#34;&#34;&#34;
        t0 = time()
        if activation is None:
            activation = self._activation
            if activation is None:
                return None
        if not isinstance(activation, Activation):
            raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
        activation = activation.raw
        self._criterion = functions.calc_classification_criterion(activation, self.prediction, y, **kwargs)
        self._time_calc_criterion = time() - t0
        self.check_thresholds(&#34;criterion&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ruleskit.rule.ClassificationRule.attributes_from_test_set"><code class="name">var <span class="ident">attributes_from_test_set</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.ClassificationRule.attributes_from_train_set"><code class="name">var <span class="ident">attributes_from_train_set</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.ClassificationRule.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.ClassificationRule.rule_index"><code class="name">var <span class="ident">rule_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ruleskit.rule.ClassificationRule.criterion"><code class="name">var <span class="ident">criterion</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def criterion(self) -&gt; float:
    return self._criterion</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.ClassificationRule.prediction"><code class="name">var <span class="ident">prediction</span> : Union[int, float, str, numpy.integer, numpy.float64, ForwardRef(None)]</code></dt>
<dd>
<div class="desc"><p>Returns the rule prediction. If rule was fitted alone, the self._prediction should be a np.ndarray
containing the probability of each class. In that case, the most probable class is returned. If the rule was
fitted in a stacked fit, then the prediction is already the most probable class and it is just returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def prediction(self) -&gt; Union[int, float, str, np.integer, np.float64, None]:
    &#34;&#34;&#34;Returns the rule prediction. If rule was fitted alone, the self._prediction should be a np.ndarray
    containing the probability of each class. In that case, the most probable class is returned. If the rule was
    fitted in a stacked fit, then the prediction is already the most probable class and it is just returned.&#34;&#34;&#34;
    if self._prediction is not None:
        if isinstance(self._prediction, (float, int, str, np.integer, np.float64)):
            return self._prediction
        prop = [p[1] for p in self._prediction]
        idx = prop.index(max(prop))
        return self._prediction[idx][0]
    else:
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ruleskit.rule.ClassificationRule.calc_criterion"><code class="name flex">
<span>def <span class="ident">calc_criterion</span></span>(<span>self, y: Union[numpy.ndarray, pandas.core.series.Series], activation: Optional[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>Union[np.ndarray, pd.Series]</code></dt>
<dd>The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
or pd.Series</dd>
<dt><strong><code>activation</code></strong> :&ensp;<code>Optional[Activation]</code></dt>
<dd>If specified, uses this activation instead of self.activation</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments for calc_classification_criterion</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_criterion(
        self,
        y: Union[np.ndarray, pd.Series],
        activation: Optional[Activation] = None,
        **kwargs
):
    &#34;&#34;&#34;
    Parameters
    ----------
    y: Union[np.ndarray, pd.Series]
        The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
        or pd.Series
    activation: Optional[Activation]
        If specified, uses this activation instead of self.activation
    kwargs: dict
        Arguments for calc_classification_criterion
    &#34;&#34;&#34;
    t0 = time()
    if activation is None:
        activation = self._activation
        if activation is None:
            return None
    if not isinstance(activation, Activation):
        raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
    activation = activation.raw
    self._criterion = functions.calc_classification_criterion(activation, self.prediction, y, **kwargs)
    self._time_calc_criterion = time() - t0
    self.check_thresholds(&#34;criterion&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.ClassificationRule.calc_prediction"><code class="name flex">
<span>def <span class="ident">calc_prediction</span></span>(<span>self, y: [<class 'numpy.ndarray'>, <class 'pandas.core.series.Series'>])</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>[np.ndarray, pd.Series]</code></dt>
<dd>The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
or pd.Series.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_prediction(self, y: [np.ndarray, pd.Series]):
    &#34;&#34;&#34;
    Parameters
    ----------
    y: [np.ndarray, pd.Series]
        The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
        or pd.Series.
    &#34;&#34;&#34;
    t0 = time()
    if self.activation is None:
        raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
    self._prediction = functions.class_probabilities(self.activation, y)
    self._time_calc_prediction = time() - t0
    self.check_thresholds(&#34;prediction&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></b></code>:
<ul class="hlist">
<li><code><a title="ruleskit.rule.Rule.SET_THRESHOLDS" href="#ruleskit.rule.Rule.SET_THRESHOLDS">SET_THRESHOLDS</a></code></li>
<li><code><a title="ruleskit.rule.Rule.THRESHOLDS" href="#ruleskit.rule.Rule.THRESHOLDS">THRESHOLDS</a></code></li>
<li><code><a title="ruleskit.rule.Rule.activation" href="#ruleskit.rule.Rule.activation">activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.activation_available" href="#ruleskit.rule.Rule.activation_available">activation_available</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_activation" href="#ruleskit.rule.Rule.calc_activation">calc_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.check_thresholds" href="#ruleskit.rule.Rule.check_thresholds">check_thresholds</a></code></li>
<li><code><a title="ruleskit.rule.Rule.del_activation" href="#ruleskit.rule.Rule.del_activation">del_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.eval" href="#ruleskit.rule.Rule.eval">eval</a></code></li>
<li><code><a title="ruleskit.rule.Rule.evaluate_activation" href="#ruleskit.rule.Rule.evaluate_activation">evaluate_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.fit" href="#ruleskit.rule.Rule.fit">fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.get_correlation" href="#ruleskit.rule.Rule.get_correlation">get_correlation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.predict" href="#ruleskit.rule.Rule.predict">predict</a></code></li>
<li><code><a title="ruleskit.rule.Rule.set_thresholds" href="#ruleskit.rule.Rule.set_thresholds">set_thresholds</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_calc_activation" href="#ruleskit.rule.Rule.time_calc_activation">time_calc_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_fit" href="#ruleskit.rule.Rule.time_fit">time_fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_predict" href="#ruleskit.rule.Rule.time_predict">time_predict</a></code></li>
<li><code><a title="ruleskit.rule.Rule.trigger_subattributes_computation" href="#ruleskit.rule.Rule.trigger_subattributes_computation">trigger_subattributes_computation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ruleskit.rule.RegressionRule"><code class="flex name class">
<span>class <span class="ident">RegressionRule</span></span>
<span>(</span><span>condition: Optional[<a title="ruleskit.condition.Condition" href="condition.html#ruleskit.condition.Condition">Condition</a>] = None, activation: Optional[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Rule applied on continuous target data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegressionRule(Rule):
    &#34;&#34;&#34;Rule applied on continuous target data.&#34;&#34;&#34;

    rule_index = Rule.rule_index + [&#34;coverage&#34;, &#34;zscore&#34;, &#34;criterion&#34;, &#34;std&#34;]
    index = Rule.condition_index + rule_index
    attributes_from_train_set = Rule.attributes_from_train_set + [&#34;prediction&#34;, &#34;std&#34;, &#34;sign&#34;, &#34;zscore&#34;]
    attributes_from_test_set = [&#34;criterion&#34;]

    def __init__(
        self,
        condition: Optional[Condition] = None,
        activation: Optional[Activation] = None,
    ):
        super().__init__(condition, activation)
        self._std = None
        self._sign = None

        # Inspection / Audit attributs
        self._time_calc_std = -1

    @property
    def std(self) -&gt; float:
        return self._std

    @property
    def sign(self) -&gt; str:
        return self._sign

    @property
    def criterion(self) -&gt; float:
        # noinspection PyTypeChecker
        return self._criterion

    @property
    def zscore(self) -&gt; float:
        return self._zscore

    @property
    def time_calc_prediction(self) -&gt; float:
        return self._time_calc_prediction

    @property
    def time_calc_criterion(self) -&gt; float:
        return self._time_calc_criterion

    @property
    def time_calc_std(self) -&gt; float:
        return self._time_calc_std

    def calc_prediction(self, y: [np.ndarray, pd.Series], activation: Optional[Activation] = None):
        &#34;&#34;&#34;Computes the mean of all activated points in target y and use it as prediction

        Parameters
        ----------
        y: [np.ndarray, pd.Series]
            The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
            or pd.Series
        activation: Optional[Activation]
            If specified, uses this activation instead of self.activation
        &#34;&#34;&#34;
        t0 = time()
        if activation is None:
            activation = self._activation
            if activation is None:
                return None
        if not isinstance(activation, Activation):
            raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
        activation = activation.raw
        self._prediction = functions.conditional_mean(activation, y)
        self._time_calc_prediction = time() - t0
        self.check_thresholds(&#34;prediction&#34;)

    def calc_sign(self):
        if self._prediction is None:
            return
        if self._prediction &lt; 0:
            self._sign = &#34;-&#34;
        else:
            self._sign = &#34;+&#34;

    def calc_std(self, y: Union[np.ndarray, pd.Series], activation: Optional[Activation] = None):
        &#34;&#34;&#34;Computes the standard deviation of all activated points in target y

        Parameters
        ----------
        y: Union[np.ndarray, pd.Series]
            The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
            or pd.Series.
        activation: Optional[Activation]
            If specified, uses this activation instead of self.activation
        &#34;&#34;&#34;
        t0 = time()
        if activation is None:
            activation = self._activation
            if activation is None:
                return None
        if not isinstance(activation, Activation):
            raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
        activation = activation.raw
        self._std = functions.conditional_std(activation, y)
        self._time_calc_std = time() - t0
        self.check_thresholds(&#34;std&#34;)

    def calc_criterion(
            self,
            y: Union[np.ndarray, pd.Series],
            activation: Optional[Activation] = None,
            **kwargs
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        y: Union[np.ndarray, pd.Series]
            The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
            or pd.Series.
        activation: Optional[Activation]
            If specified, uses this activation instead of self.activation
        kwargs: dict
            Arguments for calc_regression_criterion
        &#34;&#34;&#34;
        t0 = time()
        if activation is None:
            activation = self._activation
            if activation is None:
                return None
        if not isinstance(activation, Activation):
            raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
        activation = activation.raw
        self._criterion = functions.calc_regression_criterion(
            self.calc_prediction_vector(activation=activation), y, **kwargs
        )
        self._time_calc_criterion = time() - t0
        self.check_thresholds(&#34;criterion&#34;)

    def calc_zscore(self, y: np.ndarray, activation: Optional[Activation] = None, horizon: int = 1):
        t0 = time()
        if activation is None:
            activation = self._activation
            if activation is None:
                return
        if not isinstance(activation, Activation):
            raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
        self._zscore = calc_zscore_external(
            prediction=self.prediction, nones=activation.nones, y=y, horizon=horizon
        )
        self.check_thresholds(&#34;zscore&#34;)
        self._time_calc_zscore = time() - t0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ruleskit.rule.RegressionRule.attributes_from_test_set"><code class="name">var <span class="ident">attributes_from_test_set</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.RegressionRule.attributes_from_train_set"><code class="name">var <span class="ident">attributes_from_train_set</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.RegressionRule.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.RegressionRule.rule_index"><code class="name">var <span class="ident">rule_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ruleskit.rule.RegressionRule.criterion"><code class="name">var <span class="ident">criterion</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def criterion(self) -&gt; float:
    # noinspection PyTypeChecker
    return self._criterion</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.sign"><code class="name">var <span class="ident">sign</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sign(self) -&gt; str:
    return self._sign</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.std"><code class="name">var <span class="ident">std</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def std(self) -&gt; float:
    return self._std</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.time_calc_criterion"><code class="name">var <span class="ident">time_calc_criterion</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_calc_criterion(self) -&gt; float:
    return self._time_calc_criterion</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.time_calc_prediction"><code class="name">var <span class="ident">time_calc_prediction</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_calc_prediction(self) -&gt; float:
    return self._time_calc_prediction</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.time_calc_std"><code class="name">var <span class="ident">time_calc_std</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_calc_std(self) -&gt; float:
    return self._time_calc_std</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.zscore"><code class="name">var <span class="ident">zscore</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zscore(self) -&gt; float:
    return self._zscore</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ruleskit.rule.RegressionRule.calc_criterion"><code class="name flex">
<span>def <span class="ident">calc_criterion</span></span>(<span>self, y: Union[numpy.ndarray, pandas.core.series.Series], activation: Optional[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>Union[np.ndarray, pd.Series]</code></dt>
<dd>The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
or pd.Series.</dd>
<dt><strong><code>activation</code></strong> :&ensp;<code>Optional[Activation]</code></dt>
<dd>If specified, uses this activation instead of self.activation</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments for calc_regression_criterion</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_criterion(
        self,
        y: Union[np.ndarray, pd.Series],
        activation: Optional[Activation] = None,
        **kwargs
):
    &#34;&#34;&#34;
    Parameters
    ----------
    y: Union[np.ndarray, pd.Series]
        The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
        or pd.Series.
    activation: Optional[Activation]
        If specified, uses this activation instead of self.activation
    kwargs: dict
        Arguments for calc_regression_criterion
    &#34;&#34;&#34;
    t0 = time()
    if activation is None:
        activation = self._activation
        if activation is None:
            return None
    if not isinstance(activation, Activation):
        raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
    activation = activation.raw
    self._criterion = functions.calc_regression_criterion(
        self.calc_prediction_vector(activation=activation), y, **kwargs
    )
    self._time_calc_criterion = time() - t0
    self.check_thresholds(&#34;criterion&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.calc_prediction"><code class="name flex">
<span>def <span class="ident">calc_prediction</span></span>(<span>self, y: [<class 'numpy.ndarray'>, <class 'pandas.core.series.Series'>], activation: Optional[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the mean of all activated points in target y and use it as prediction</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>[np.ndarray, pd.Series]</code></dt>
<dd>The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
or pd.Series</dd>
<dt><strong><code>activation</code></strong> :&ensp;<code>Optional[Activation]</code></dt>
<dd>If specified, uses this activation instead of self.activation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_prediction(self, y: [np.ndarray, pd.Series], activation: Optional[Activation] = None):
    &#34;&#34;&#34;Computes the mean of all activated points in target y and use it as prediction

    Parameters
    ----------
    y: [np.ndarray, pd.Series]
        The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
        or pd.Series
    activation: Optional[Activation]
        If specified, uses this activation instead of self.activation
    &#34;&#34;&#34;
    t0 = time()
    if activation is None:
        activation = self._activation
        if activation is None:
            return None
    if not isinstance(activation, Activation):
        raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
    activation = activation.raw
    self._prediction = functions.conditional_mean(activation, y)
    self._time_calc_prediction = time() - t0
    self.check_thresholds(&#34;prediction&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.calc_sign"><code class="name flex">
<span>def <span class="ident">calc_sign</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_sign(self):
    if self._prediction is None:
        return
    if self._prediction &lt; 0:
        self._sign = &#34;-&#34;
    else:
        self._sign = &#34;+&#34;</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.calc_std"><code class="name flex">
<span>def <span class="ident">calc_std</span></span>(<span>self, y: Union[numpy.ndarray, pandas.core.series.Series], activation: Optional[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the standard deviation of all activated points in target y</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>Union[np.ndarray, pd.Series]</code></dt>
<dd>The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
or pd.Series.</dd>
<dt><strong><code>activation</code></strong> :&ensp;<code>Optional[Activation]</code></dt>
<dd>If specified, uses this activation instead of self.activation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_std(self, y: Union[np.ndarray, pd.Series], activation: Optional[Activation] = None):
    &#34;&#34;&#34;Computes the standard deviation of all activated points in target y

    Parameters
    ----------
    y: Union[np.ndarray, pd.Series]
        The targets on which to evaluate the rule prediction, and possibly other criteria. Must be a 1-D np.ndarray
        or pd.Series.
    activation: Optional[Activation]
        If specified, uses this activation instead of self.activation
    &#34;&#34;&#34;
    t0 = time()
    if activation is None:
        activation = self._activation
        if activation is None:
            return None
    if not isinstance(activation, Activation):
        raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
    activation = activation.raw
    self._std = functions.conditional_std(activation, y)
    self._time_calc_std = time() - t0
    self.check_thresholds(&#34;std&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.calc_zscore"><code class="name flex">
<span>def <span class="ident">calc_zscore</span></span>(<span>self, y: numpy.ndarray, activation: Optional[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>] = None, horizon: int = 1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_zscore(self, y: np.ndarray, activation: Optional[Activation] = None, horizon: int = 1):
    t0 = time()
    if activation is None:
        activation = self._activation
        if activation is None:
            return
    if not isinstance(activation, Activation):
        raise TypeError(&#34;Needs &#39;Activation&#39; type activation vector&#34;)
    self._zscore = calc_zscore_external(
        prediction=self.prediction, nones=activation.nones, y=y, horizon=horizon
    )
    self.check_thresholds(&#34;zscore&#34;)
    self._time_calc_zscore = time() - t0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></b></code>:
<ul class="hlist">
<li><code><a title="ruleskit.rule.Rule.SET_THRESHOLDS" href="#ruleskit.rule.Rule.SET_THRESHOLDS">SET_THRESHOLDS</a></code></li>
<li><code><a title="ruleskit.rule.Rule.THRESHOLDS" href="#ruleskit.rule.Rule.THRESHOLDS">THRESHOLDS</a></code></li>
<li><code><a title="ruleskit.rule.Rule.activation" href="#ruleskit.rule.Rule.activation">activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.activation_available" href="#ruleskit.rule.Rule.activation_available">activation_available</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_activation" href="#ruleskit.rule.Rule.calc_activation">calc_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.check_thresholds" href="#ruleskit.rule.Rule.check_thresholds">check_thresholds</a></code></li>
<li><code><a title="ruleskit.rule.Rule.del_activation" href="#ruleskit.rule.Rule.del_activation">del_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.eval" href="#ruleskit.rule.Rule.eval">eval</a></code></li>
<li><code><a title="ruleskit.rule.Rule.evaluate_activation" href="#ruleskit.rule.Rule.evaluate_activation">evaluate_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.fit" href="#ruleskit.rule.Rule.fit">fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.get_correlation" href="#ruleskit.rule.Rule.get_correlation">get_correlation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.predict" href="#ruleskit.rule.Rule.predict">predict</a></code></li>
<li><code><a title="ruleskit.rule.Rule.set_thresholds" href="#ruleskit.rule.Rule.set_thresholds">set_thresholds</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_calc_activation" href="#ruleskit.rule.Rule.time_calc_activation">time_calc_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_fit" href="#ruleskit.rule.Rule.time_fit">time_fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_predict" href="#ruleskit.rule.Rule.time_predict">time_predict</a></code></li>
<li><code><a title="ruleskit.rule.Rule.trigger_subattributes_computation" href="#ruleskit.rule.Rule.trigger_subattributes_computation">trigger_subattributes_computation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ruleskit.rule.Rule"><code class="flex name class">
<span>class <span class="ident">Rule</span></span>
<span>(</span><span>condition: Optional[<a title="ruleskit.condition.Condition" href="condition.html#ruleskit.condition.Condition">Condition</a>] = None, activation: Optional[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>An abstract Rule object.</p>
<p>A Rule is a condition (represented by any daughter class of ruleskit.Condition), applied on real features and target
data.
The Rule contains, in addition to the Condition object, many attributes dependent on the features data, such as
the activation vector (a 1-D np.ndarray with 0 when the rule is activated - condition is met - and 0 when it is not)
but also the rule's prediction (computed in the daughter class).</p>
<p>Daughter classes can remember more attributes (precision, user-definded criterion&hellip;).</p>
<p>Rule also include metrics that can be used for profiling the code : it will remember the time taken to fit the rule
(fitting is the computation of the rule's attribute from the condition and the features data), the time taken
to compute the activation vector and the time taken to make a prediction.</p>
<p>To compute those metrics, one must use the rule's "fit" methods. Once this is done, one cas use the "predict"
methods on a different set of features data.</p>
<p>The Rule object can access any attribute of its condition as if it was its own : rule.features_indexes will return
the features_indexes attribute's value of the condition in the Rule object. See Condition class for more details.</p>
<p>The Rule object can also access any attribute of its activation vector as if it was its own. See Activation class
for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rule(ABC):

    &#34;&#34;&#34;An abstract Rule object.

    A Rule is a condition (represented by any daughter class of ruleskit.Condition), applied on real features and target
    data.
    The Rule contains, in addition to the Condition object, many attributes dependent on the features data, such as
    the activation vector (a 1-D np.ndarray with 0 when the rule is activated - condition is met - and 0 when it is not)
    but also the rule&#39;s prediction (computed in the daughter class).

    Daughter classes can remember more attributes (precision, user-definded criterion...).

    Rule also include metrics that can be used for profiling the code : it will remember the time taken to fit the rule
    (fitting is the computation of the rule&#39;s attribute from the condition and the features data), the time taken
    to compute the activation vector and the time taken to make a prediction.

    To compute those metrics, one must use the rule&#39;s &#34;fit&#34; methods. Once this is done, one cas use the &#34;predict&#34;
     methods on a different set of features data.

    The Rule object can access any attribute of its condition as if it was its own : rule.features_indexes will return
    the features_indexes attribute&#39;s value of the condition in the Rule object. See Condition class for more details.

    The Rule object can also access any attribute of its activation vector as if it was its own. See Activation class
    for more details.
    &#34;&#34;&#34;

    LOCAL_ACTIVATION = True
    THRESHOLDS = None
    &#34;&#34;&#34;Thresholds that the Rule must meet to be good. See `ruleskit.thresholds.Thresholds` for more details.&#34;&#34;&#34;

    condition_index = [&#34;features_names&#34;, &#34;features_indexes&#34;, &#34;bmins&#34;, &#34;bmaxs&#34;]
    rule_index = [&#34;prediction&#34;]
    index = condition_index + rule_index

    attributes_from_test_set = [&#34;test_set_size&#34;]
    attributes_from_train_set = [&#34;train_set_size&#34;]

    fitted_if_has = &#34;prediction&#34;

    daughters = []

    # noinspection PyUnresolvedReferences
    @classmethod
    def SET_THRESHOLDS(cls, path: Union[str, Path, &#34;TransparentPath&#34;, None], show=False):
        &#34;&#34;&#34;Set thresholds globally for all futur Rules&#34;&#34;&#34;
        if path is None:
            cls.THRESHOLDS = None
        else:
            cls.THRESHOLDS = Thresholds(path, show)

    def __init__(
        self,
        condition: Optional[Condition] = None,
        activation: Optional[Activation] = None,
    ):

        if condition is not None and not isinstance(condition, Condition):
            raise TypeError(&#34;Argument &#39;condition&#39; must derive from Condition or be None.&#34;)
        if activation is not None and not isinstance(activation, Activation):
            raise TypeError(&#34;Argument &#39;activation&#39; must derive from Activation or be None.&#34;)
        if activation is not None and condition is None:
            raise ValueError(&#34;Condition can not be None if activation is not None&#34;)

        self._condition: Optional[Condition] = condition
        self._activation: Optional[Activation] = activation
        self._thresholds: Optional[Thresholds] = self.__class__.THRESHOLDS
        self._good: bool = True
        self._bad_because: Optional[str] = None

        self._coverage: Optional[float] = None
        self._prediction: Optional[Union[float, str, int]] = None
        self._criterion: Optional[float] = None
        self._zscore: Optional[float] = None

        self._time_fit: float = -1
        self._time_eval: float = -1
        self._time_calc_activation: float = -1
        self._time_predict: float = -1
        self._time_calc_prediction: float = -1
        self._time_calc_criterion: float = -1
        self._time_calc_zscore: float = -1
        self._fitted: bool = False
        self._evaluated = False
        self._train_set_size: Optional[int] = None
        self._test_set_size: Optional[int] = None
        if self._activation is not None:
            self.check_thresholds(&#34;coverage&#34;)

    # noinspection PyUnresolvedReferences
    def set_thresholds(self, path: Union[str, Path, &#34;TransparentPath&#34;], show=False):
        &#34;&#34;&#34;Set thresholds for this rule only&#34;&#34;&#34;
        if path is None:
            self._thresholds.THRESHOLDS = None
        else:
            self._thresholds = Thresholds(path, show)

    def check_thresholds(self, attribute: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;If `ruleskit.rule.Rule.THRESHOLDS` is specified, will check that this rule is good regarding those
        thresholds, and set the flags *good* and *bad_because* accordingly

        Parameters
        ----------
        attribute: Optional[str]
            If specified, will only check the threshold of this rule attribute. If not, will test every rule attributes
            for which a threshold is defined.
        &#34;&#34;&#34;

        if self.__class__.THRESHOLDS is None:
            return

        if attribute is not None:
            if not self.__class__.THRESHOLDS(attribute, self):
                self._bad_because = attribute
                self._good = False
            return

        for attribute in dir(self):
            if attribute.startswith(&#34;__&#34;):
                continue
            if not self.__class__.THRESHOLDS(attribute, self):
                self._bad_because = attribute
                self._good = False
                return
        logger.debug(f&#34;Rule {self} is good&#34;)

    def __and__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        &#34;&#34;&#34;Logical AND (&amp;) of two rules. It is simply the logical AND of the two rule&#39;s conditions and activations.&#34;&#34;&#34;
        condition = self._condition &amp; other._condition
        activation = self._activation &amp; other._activation
        return self.__class__(condition, activation)

    def __add__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        return NotImplemented(&#34;Can not add rules (seen as &#39;logical OR&#39;). You can use logical AND however.&#34;)

    # def __del__(self):
    #     self.del_activation()

    def del_activation(self):
        &#34;&#34;&#34;Deletes the activation vector&#39;s data, but not the object itself, so any computed attributes will remain
        available&#34;&#34;&#34;
        if hasattr(self, &#34;_activation&#34;) and self._activation is not None:
            self._activation.delete()

    @property
    def activation_available(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the rule has an activation vector, and if this Activation&#39;s object data is available.&#34;&#34;&#34;
        if self._activation is None:
            return False
        if self._activation.data_format == &#34;file&#34;:
            return self._activation.data.is_file()
        else:
            return self._activation.data is not None

    @property
    def coverage(self) -&gt; float:
        if self._activation is not None:
            self._coverage = self._activation.coverage
            return self._activation.coverage
        return self._coverage

    @coverage.setter
    def coverage(self, value: Union[int, None]):
        if self._activation is not None:
            self._activation._coverage = value
        self._coverage = value

    @property
    def train_set_size(self) -&gt; int:
        return self._train_set_size

    @property
    def test_set_size(self) -&gt; int:
        return self._test_set_size

    @train_set_size.setter
    def train_set_size(self, value: Union[int, None]):
        self._train_set_size = value

    @test_set_size.setter
    def test_set_size(self, value: Union[int, None]):
        self._test_set_size = value

    @property
    def condition(self) -&gt; Condition:
        return self._condition

    @property
    def activation(self) -&gt; Union[None, np.ndarray]:
        &#34;&#34;&#34;Returns the Activation vector&#39;s data in a form of a 1-D np.ndarray, or None if not available.

        Returns
        -------
        np.ndarray
            of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, ...]
        &#34;&#34;&#34;
        if self._activation:
            return self._activation.raw
        return None

    @property
    def prediction(self) -&gt; Union[str, float]:
        return self._prediction

    @property
    def thresholds(self) -&gt; Thresholds:
        return self._thresholds

    @property
    def good(self) -&gt; bool:
        return self._good

    @property
    def bad_because(self) -&gt; str:
        return self._bad_because

    @property
    def time_fit(self) -&gt; float:
        &#34;&#34;&#34;Profiling attribute. Time in seconds taken to fit the rule&#34;&#34;&#34;
        return self._time_fit

    @property
    def time_predict(self) -&gt; float:
        &#34;&#34;&#34;Profiling attribute. Time in seconds taken by the rule to make a prediction&#34;&#34;&#34;
        return self._time_predict

    @property
    def time_calc_activation(self) -&gt; float:
        &#34;&#34;&#34;Profiling attribute. Time in seconds taken to comptue the activation vector&#34;&#34;&#34;
        return self._time_calc_activation

    def __getattr__(self, item):
        &#34;&#34;&#34;If item is not found in self, try to fetch it from its activation or condition.&#34;&#34;&#34;
        if item == &#34;_activation&#34; or item == &#34;_condition&#34;:
            raise AttributeError(f&#34;&#39;Rule&#39; object has no attribute &#39;{item}&#39;.&#34;)

        if hasattr(self._activation, item):
            return getattr(self._activation, item)
        if hasattr(self._condition, item):
            return getattr(self._condition, item)
        raise AttributeError(f&#34;&#39;Rule&#39; object has no attribute &#39;{item}&#39;.&#34;)

    def __setattr__(self, item, value):
        &#34;&#34;&#34;If item is private (starts with _), then default behavior. Else, if the item is not yet known by the rule
        but is known by its condition or activation, will set it to the condition or the activation. Else,
        raises AttributeError.&#34;&#34;&#34;
        if item.startswith(&#34;_&#34;):
            super(Rule, self).__setattr__(item, value)
            return
        if not hasattr(self, item):
            if hasattr(self._activation, item):
                setattr(self._activation, item, value)
            elif hasattr(self._condition, item):
                setattr(self._condition, item, value)
            else:
                raise AttributeError(f&#34;Can not set attribute &#39;{item}&#39; in object Rule.&#34;)
        else:
            super(Rule, self).__setattr__(item, value)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Two rules are equal if their conditions are equal.&#34;&#34;&#34;
        if not isinstance(other, Rule):
            return False
        else:
            return self._condition == other._condition

    def __contains__(self, other: &#34;Rule&#34;) -&gt; bool:
        &#34;&#34;&#34;
        A Rule contains another Rule if the second rule&#39;s activated points are also all activated by the first
        rule.
        &#34;&#34;&#34;
        if not self._activation or not other._activation:
            return False
        return other._activation in self._activation

    def __str__(self) -&gt; str:
        prediction = &#34;&lt;prediction unset&gt;&#34;
        if self._prediction is not None:
            prediction = self._prediction
        if self._condition is None:
            return &#34;empty rule&#34;
        return f&#34;If {self._condition.__str__()} Then {prediction}.&#34;

    @property
    def to_hash(self) -&gt; Tuple[str]:
        return (&#34;r&#34;,) + self._condition.to_hash[1:]

    def __hash__(self) -&gt; hash:
        return hash(frozenset(self.to_hash))

    def __len__(self):
        &#34;&#34;&#34;A Rule&#39;s length is the number of features it talks about&#34;&#34;&#34;
        return len(self._condition)

    def evaluate_activation(self, xs: Union[pd.DataFrame, np.ndarray]) -&gt; Activation:
        &#34;&#34;&#34;Computes and returns the activation vector from an array of features.

        Parameters
        ----------
        xs: Union[pd:DataFrame, np.ndarray]
            The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
            or pd:DataFrame.

        Returns
        -------
        Activation
        &#34;&#34;&#34;
        arr = self._condition.evaluate(xs)
        # noinspection PyTypeChecker
        a = Activation(arr, to_file=self.__class__.LOCAL_ACTIVATION)
        return a

    def fit(
        self,
        y: Union[np.ndarray, pd.Series],
        xs: Optional[Union[pd.DataFrame, np.ndarray]] = None,
        force_if_not_good: bool = False,
        **kwargs
    ):
        &#34;&#34;&#34;Computes activation and attributes relevant to the train set

        Parameters
        ----------
        y: Union[np.ndarray, pd.Series]
        xs: Union[pd.DataFrame, np.ndarray]
        force_if_not_good: bool
        kwargs: dict
            Additionnal keyword arguments for calc_&lt;any_attribute&gt;
        &#34;&#34;&#34;

        if &#34;method&#34; in kwargs:
            raise IndexError(&#34;Key &#39;method&#39; can not be given to &#39;fit&#39;&#34;)

        if self._fitted and xs is None:
            return

        t0 = time()

        def launch_method(method, **kw):
            expected_args = list(inspect.signature(method).parameters)
            if &#34;kwargs&#34; not in expected_args:
                kw = {item: kw[item] for item in kw if item in expected_args}
            method(**kw)

        if xs is not None and len(xs) == 0:
            logger.warning(&#34;Given xs is empty&#34;)
            return

        self.calc_activation(xs=xs)

        for attr in self.__class__.attributes_from_train_set:
            if attr == &#34;activation&#34;:
                raise ValueError(&#34;&#39;activation&#39; can not be specified in &#39;attributes_from_train_set&#39;&#34;)
            if not self.good and not force_if_not_good:
                setattr(self, f&#34;_{attr}&#34;, np.nan)
                continue
            launch_method(getattr(self, f&#34;calc_{attr}&#34;), y=y, xs=xs, **kwargs)
            if self.good:
                self.check_thresholds(attr)

        if self.good:
            self.check_thresholds()
        self.trigger_subattributes_computation()
        self._time_fit = time() - t0
        self._fitted = True

    def eval(
        self,
        y: Union[np.ndarray, pd.Series],
        xs: Optional[Union[pd.DataFrame, np.ndarray]] = None,
        recompute_activation: bool = False,
        force_if_not_good: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;Computes prediction, standard deviation, and regression criterion

        Parameters
        ----------
        y: Union[np.ndarray, pd.Series]
        xs: Union[pd.DataFrame, np.ndarray]
        recompute_activation: bool
            To reset self.activation using the given xs
        force_if_not_good: bool
            If the rule was seen as &#34;bad&#34;, eval will not trigger unless this boolean is True (Default value = False)
        kwargs
            Additionnal keyword arguments for calc_&lt;any_attribute&gt;
        &#34;&#34;&#34;

        if &#34;method&#34; in kwargs:
            raise IndexError(&#34;Key &#39;method&#39; can not be given to &#39;eval&#39;&#34;)

        t0 = time()

        if not self.good and not force_if_not_good:
            self._time_eval = time() - t0
            self._fitted = True
            for attr in self.__class__.attributes_from_test_set:
                setattr(self, f&#34;_{attr}&#34;, np.nan)
            return

        def launch_method(method, **kw):
            expected_args = list(inspect.signature(method).parameters)
            if &#34;kwargs&#34; not in expected_args:
                kw = {item: kw[item] for item in kw if item in expected_args}
            method(**kw)

        if xs is not None and len(xs) == 0:
            logger.warning(&#34;Given xs is empty&#34;)
            return

        if recompute_activation:
            self.calc_activation(xs=xs)
            xs = None

        if not self.activation_available:
            raise ValueError(
                &#34;Must have fitted the rule before calling &#39;eval&#39;, or use &#39;recompute_activation=True&#39; to recompute it&#34;
                &#34; from given xs&#34;
            )

        if xs is not None:
            activation = self.evaluate_activation(xs)
        else:
            activation = self._activation

        for attr in self.__class__.attributes_from_test_set:
            if attr == &#34;activation&#34;:
                raise ValueError(&#34;&#39;activation&#39; can not be specified in &#39;attributes_from_test_set&#39;&#34;)
            if not self.good and not force_if_not_good:
                setattr(self, f&#34;_{attr}&#34;, np.nan)
                continue
            launch_method(getattr(self, f&#34;calc_{attr}&#34;), y=y, xs=xs, activation=activation, **kwargs)
            if self.good:
                self.check_thresholds(attr)

        if self.good:
            self.check_thresholds()
        self._time_eval = time() - t0
        self._evaluated = True

    def trigger_subattributes_computation(self):
        &#34;&#34;&#34;Uses getattr(self, attr) to trigger important attributes computation. Important attributes should be
        Ruleset.rule_index&#34;&#34;&#34;
        for attr in self.__class__.index:
            _ = getattr(self, attr)

    def calc_prediction_vector(self, activation: Optional[np.ndarray] = None) -&gt; Union[None, pd.Series]:
        if activation is None:
            activation = self.activation
        if activation is None:
            return None
        if self.prediction is None:
            return pd.Series(np.nan * activation)
        if len(self) == 0:
            return pd.Series(dtype=int)
        if isinstance(self.prediction, str):
            pred = pd.Series(np.where(activation == 0, np.nan, activation))
            pred[pred == 1] = self.prediction
            return pred
        else:
            # noinspection PyUnresolvedReferences
            return self.prediction * pd.Series(np.where(activation == 0, np.nan, activation))

    def predict(self, xs: Optional[Union[pd.DataFrame, np.ndarray]] = None) -&gt; Union[np.ndarray, pd.Series]:
        &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
        Will raise ValueError is xs is None and activation is not yet known.

        Parameters
        ----------
        xs: Optional[Union[pd.DataFrame, np.ndarray]]
            The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
            or pd:DataFrame. If not specified the rule&#39;s activation vector must have been computed already.

        Returns
        -------
        Union[np.ndarray, pd.Series]
            np.nan where rule is not activated, rule&#39;s prediction where it is. If xs vas given and it was a dataframe,
            return a pd.Series. Else, a np.ndarray.
        &#34;&#34;&#34;
        t0 = time()
        if xs is not None:
            act = self.evaluate_activation(xs).raw
        elif self.activation is None:
            raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
        else:
            act = self.activation
        to_ret = np.array([np.nan] * len(act))
        if isinstance(self.prediction, str):
            if self.prediction == &#34;nan&#34;:
                raise ValueError(
                    &#34;Prediction should not be the &#39;nan&#39; string, it will conflict with NaNs. Rename your class.&#34;
                )
            to_ret = to_ret.astype(str)
        to_ret[act == 1] = self.prediction
        if xs is not None and not isinstance(xs, np.ndarray):
            to_ret = xs.__class__(index=xs.index, data=to_ret).squeeze()  # So not to requier pandas explicitly
        self._time_predict = time() - t0
        return to_ret

    def get_correlation(self, other: &#34;Rule&#34;) -&gt; float:
        &#34;&#34;&#34;Computes the correlation between self and other
        Correlation is the number of points in common between the two vectors divided by their length, times the product
        of the rules&#39; signs.
        Both vectors must have the same length.
        &#34;&#34;&#34;
        if not len(self) == len(other):
            raise ValueError(&#34;Both vectors must have the same length&#34;)

        sign = (self.prediction / abs(self.prediction)) * (other.prediction / abs(other.prediction))
        return self._activation.get_correlation(other._activation) * sign

    def calc_activation(self, xs: Optional[Union[pd.DataFrame, np.ndarray]] = None):
        &#34;&#34;&#34;Uses self.evaluate to set self._activation.

        Parameters
        ----------
        xs: Union[pd.DataFrame, np.ndarray, None]
            The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
            or pd:DataFrame.
        &#34;&#34;&#34;
        if xs is None:
            if self._activation is None:
                raise ValueError(
                    &#34;If calling calc_activation without specifying xs, activation must have been computed already.&#34;
                )
            return
        t0 = time()

        if len(xs) == 0:
            logger.warning(&#34;Given xs is empty&#34;)
            return
        self._activation = self.evaluate_activation(xs)
        self._time_calc_activation = time() - t0
        self.check_thresholds(&#34;coverage&#34;)

    def calc_train_set_size(self, y: Union[np.ndarray, pd.Series]):
        if isinstance(y, (pd.Series, pd.DataFrame)):
            self.train_set_size = len(y.index)
        else:
            self.train_set_size = len(y)

    def calc_test_set_size(self, y: Union[np.ndarray, pd.Series]):
        if isinstance(y, (pd.Series, pd.DataFrame)):
            self.test_set_size = len(y.index)
        else:
            self.test_set_size = len(y)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ruleskit.rule.ClassificationRule" href="#ruleskit.rule.ClassificationRule">ClassificationRule</a></li>
<li><a title="ruleskit.rule.RegressionRule" href="#ruleskit.rule.RegressionRule">RegressionRule</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ruleskit.rule.Rule.LOCAL_ACTIVATION"><code class="name">var <span class="ident">LOCAL_ACTIVATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.Rule.THRESHOLDS"><code class="name">var <span class="ident">THRESHOLDS</span></code></dt>
<dd>
<div class="desc"><p>Thresholds that the Rule must meet to be good. See <code><a title="ruleskit.thresholds.Thresholds" href="thresholds.html#ruleskit.thresholds.Thresholds">Thresholds</a></code> for more details.</p></div>
</dd>
<dt id="ruleskit.rule.Rule.attributes_from_test_set"><code class="name">var <span class="ident">attributes_from_test_set</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.Rule.attributes_from_train_set"><code class="name">var <span class="ident">attributes_from_train_set</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.Rule.condition_index"><code class="name">var <span class="ident">condition_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.Rule.daughters"><code class="name">var <span class="ident">daughters</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.Rule.fitted_if_has"><code class="name">var <span class="ident">fitted_if_has</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.Rule.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.rule.Rule.rule_index"><code class="name">var <span class="ident">rule_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="ruleskit.rule.Rule.SET_THRESHOLDS"><code class="name flex">
<span>def <span class="ident">SET_THRESHOLDS</span></span>(<span>path: Union[str, pathlib.Path, ForwardRef('TransparentPath'), ForwardRef(None)], show=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set thresholds globally for all futur Rules</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def SET_THRESHOLDS(cls, path: Union[str, Path, &#34;TransparentPath&#34;, None], show=False):
    &#34;&#34;&#34;Set thresholds globally for all futur Rules&#34;&#34;&#34;
    if path is None:
        cls.THRESHOLDS = None
    else:
        cls.THRESHOLDS = Thresholds(path, show)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ruleskit.rule.Rule.activation"><code class="name">var <span class="ident">activation</span> : Optional[None]</code></dt>
<dd>
<div class="desc"><p>Returns the Activation vector's data in a form of a 1-D np.ndarray, or None if not available.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, &hellip;]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def activation(self) -&gt; Union[None, np.ndarray]:
    &#34;&#34;&#34;Returns the Activation vector&#39;s data in a form of a 1-D np.ndarray, or None if not available.

    Returns
    -------
    np.ndarray
        of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, ...]
    &#34;&#34;&#34;
    if self._activation:
        return self._activation.raw
    return None</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.activation_available"><code class="name">var <span class="ident">activation_available</span> : bool</code></dt>
<dd>
<div class="desc"><p>Returns True if the rule has an activation vector, and if this Activation's object data is available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def activation_available(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the rule has an activation vector, and if this Activation&#39;s object data is available.&#34;&#34;&#34;
    if self._activation is None:
        return False
    if self._activation.data_format == &#34;file&#34;:
        return self._activation.data.is_file()
    else:
        return self._activation.data is not None</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.bad_because"><code class="name">var <span class="ident">bad_because</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bad_because(self) -&gt; str:
    return self._bad_because</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.condition"><code class="name">var <span class="ident">condition</span> : <a title="ruleskit.condition.Condition" href="condition.html#ruleskit.condition.Condition">Condition</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def condition(self) -&gt; Condition:
    return self._condition</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.coverage"><code class="name">var <span class="ident">coverage</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coverage(self) -&gt; float:
    if self._activation is not None:
        self._coverage = self._activation.coverage
        return self._activation.coverage
    return self._coverage</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.good"><code class="name">var <span class="ident">good</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def good(self) -&gt; bool:
    return self._good</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.prediction"><code class="name">var <span class="ident">prediction</span> : Union[str, float]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def prediction(self) -&gt; Union[str, float]:
    return self._prediction</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.test_set_size"><code class="name">var <span class="ident">test_set_size</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def test_set_size(self) -&gt; int:
    return self._test_set_size</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.thresholds"><code class="name">var <span class="ident">thresholds</span> : <a title="ruleskit.thresholds.Thresholds" href="thresholds.html#ruleskit.thresholds.Thresholds">Thresholds</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def thresholds(self) -&gt; Thresholds:
    return self._thresholds</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.time_calc_activation"><code class="name">var <span class="ident">time_calc_activation</span> : float</code></dt>
<dd>
<div class="desc"><p>Profiling attribute. Time in seconds taken to comptue the activation vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_calc_activation(self) -&gt; float:
    &#34;&#34;&#34;Profiling attribute. Time in seconds taken to comptue the activation vector&#34;&#34;&#34;
    return self._time_calc_activation</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.time_fit"><code class="name">var <span class="ident">time_fit</span> : float</code></dt>
<dd>
<div class="desc"><p>Profiling attribute. Time in seconds taken to fit the rule</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_fit(self) -&gt; float:
    &#34;&#34;&#34;Profiling attribute. Time in seconds taken to fit the rule&#34;&#34;&#34;
    return self._time_fit</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.time_predict"><code class="name">var <span class="ident">time_predict</span> : float</code></dt>
<dd>
<div class="desc"><p>Profiling attribute. Time in seconds taken by the rule to make a prediction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_predict(self) -&gt; float:
    &#34;&#34;&#34;Profiling attribute. Time in seconds taken by the rule to make a prediction&#34;&#34;&#34;
    return self._time_predict</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.to_hash"><code class="name">var <span class="ident">to_hash</span> : Tuple[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def to_hash(self) -&gt; Tuple[str]:
    return (&#34;r&#34;,) + self._condition.to_hash[1:]</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.train_set_size"><code class="name">var <span class="ident">train_set_size</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def train_set_size(self) -&gt; int:
    return self._train_set_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ruleskit.rule.Rule.calc_activation"><code class="name flex">
<span>def <span class="ident">calc_activation</span></span>(<span>self, xs: Union[pandas.core.frame.DataFrame, numpy.ndarray, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses self.evaluate to set self._activation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xs</code></strong> :&ensp;<code>Union[pd.DataFrame, np.ndarray, None]</code></dt>
<dd>The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
or pd:DataFrame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_activation(self, xs: Optional[Union[pd.DataFrame, np.ndarray]] = None):
    &#34;&#34;&#34;Uses self.evaluate to set self._activation.

    Parameters
    ----------
    xs: Union[pd.DataFrame, np.ndarray, None]
        The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
        or pd:DataFrame.
    &#34;&#34;&#34;
    if xs is None:
        if self._activation is None:
            raise ValueError(
                &#34;If calling calc_activation without specifying xs, activation must have been computed already.&#34;
            )
        return
    t0 = time()

    if len(xs) == 0:
        logger.warning(&#34;Given xs is empty&#34;)
        return
    self._activation = self.evaluate_activation(xs)
    self._time_calc_activation = time() - t0
    self.check_thresholds(&#34;coverage&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.calc_prediction_vector"><code class="name flex">
<span>def <span class="ident">calc_prediction_vector</span></span>(<span>self, activation: Optional[None] = None) ‑> Optional[None]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_prediction_vector(self, activation: Optional[np.ndarray] = None) -&gt; Union[None, pd.Series]:
    if activation is None:
        activation = self.activation
    if activation is None:
        return None
    if self.prediction is None:
        return pd.Series(np.nan * activation)
    if len(self) == 0:
        return pd.Series(dtype=int)
    if isinstance(self.prediction, str):
        pred = pd.Series(np.where(activation == 0, np.nan, activation))
        pred[pred == 1] = self.prediction
        return pred
    else:
        # noinspection PyUnresolvedReferences
        return self.prediction * pd.Series(np.where(activation == 0, np.nan, activation))</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.calc_test_set_size"><code class="name flex">
<span>def <span class="ident">calc_test_set_size</span></span>(<span>self, y: Union[numpy.ndarray, pandas.core.series.Series])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_test_set_size(self, y: Union[np.ndarray, pd.Series]):
    if isinstance(y, (pd.Series, pd.DataFrame)):
        self.test_set_size = len(y.index)
    else:
        self.test_set_size = len(y)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.calc_train_set_size"><code class="name flex">
<span>def <span class="ident">calc_train_set_size</span></span>(<span>self, y: Union[numpy.ndarray, pandas.core.series.Series])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_train_set_size(self, y: Union[np.ndarray, pd.Series]):
    if isinstance(y, (pd.Series, pd.DataFrame)):
        self.train_set_size = len(y.index)
    else:
        self.train_set_size = len(y)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.check_thresholds"><code class="name flex">
<span>def <span class="ident">check_thresholds</span></span>(<span>self, attribute: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>If <code><a title="ruleskit.rule.Rule.THRESHOLDS" href="#ruleskit.rule.Rule.THRESHOLDS">Rule.THRESHOLDS</a></code> is specified, will check that this rule is good regarding those
thresholds, and set the flags <em>good</em> and <em>bad_because</em> accordingly</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>attribute</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>If specified, will only check the threshold of this rule attribute. If not, will test every rule attributes
for which a threshold is defined.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_thresholds(self, attribute: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;If `ruleskit.rule.Rule.THRESHOLDS` is specified, will check that this rule is good regarding those
    thresholds, and set the flags *good* and *bad_because* accordingly

    Parameters
    ----------
    attribute: Optional[str]
        If specified, will only check the threshold of this rule attribute. If not, will test every rule attributes
        for which a threshold is defined.
    &#34;&#34;&#34;

    if self.__class__.THRESHOLDS is None:
        return

    if attribute is not None:
        if not self.__class__.THRESHOLDS(attribute, self):
            self._bad_because = attribute
            self._good = False
        return

    for attribute in dir(self):
        if attribute.startswith(&#34;__&#34;):
            continue
        if not self.__class__.THRESHOLDS(attribute, self):
            self._bad_because = attribute
            self._good = False
            return
    logger.debug(f&#34;Rule {self} is good&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.del_activation"><code class="name flex">
<span>def <span class="ident">del_activation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the activation vector's data, but not the object itself, so any computed attributes will remain
available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_activation(self):
    &#34;&#34;&#34;Deletes the activation vector&#39;s data, but not the object itself, so any computed attributes will remain
    available&#34;&#34;&#34;
    if hasattr(self, &#34;_activation&#34;) and self._activation is not None:
        self._activation.delete()</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>self, y: Union[numpy.ndarray, pandas.core.series.Series], xs: Union[pandas.core.frame.DataFrame, numpy.ndarray, ForwardRef(None)] = None, recompute_activation: bool = False, force_if_not_good: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes prediction, standard deviation, and regression criterion</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>Union[np.ndarray, pd.Series]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>xs</code></strong> :&ensp;<code>Union[pd.DataFrame, np.ndarray]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>recompute_activation</code></strong> :&ensp;<code>bool</code></dt>
<dd>To reset self.activation using the given xs</dd>
<dt><strong><code>force_if_not_good</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the rule was seen as "bad", eval will not trigger unless this boolean is True (Default value = False)</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Additionnal keyword arguments for calc_<any_attribute></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval(
    self,
    y: Union[np.ndarray, pd.Series],
    xs: Optional[Union[pd.DataFrame, np.ndarray]] = None,
    recompute_activation: bool = False,
    force_if_not_good: bool = False,
    **kwargs,
):
    &#34;&#34;&#34;Computes prediction, standard deviation, and regression criterion

    Parameters
    ----------
    y: Union[np.ndarray, pd.Series]
    xs: Union[pd.DataFrame, np.ndarray]
    recompute_activation: bool
        To reset self.activation using the given xs
    force_if_not_good: bool
        If the rule was seen as &#34;bad&#34;, eval will not trigger unless this boolean is True (Default value = False)
    kwargs
        Additionnal keyword arguments for calc_&lt;any_attribute&gt;
    &#34;&#34;&#34;

    if &#34;method&#34; in kwargs:
        raise IndexError(&#34;Key &#39;method&#39; can not be given to &#39;eval&#39;&#34;)

    t0 = time()

    if not self.good and not force_if_not_good:
        self._time_eval = time() - t0
        self._fitted = True
        for attr in self.__class__.attributes_from_test_set:
            setattr(self, f&#34;_{attr}&#34;, np.nan)
        return

    def launch_method(method, **kw):
        expected_args = list(inspect.signature(method).parameters)
        if &#34;kwargs&#34; not in expected_args:
            kw = {item: kw[item] for item in kw if item in expected_args}
        method(**kw)

    if xs is not None and len(xs) == 0:
        logger.warning(&#34;Given xs is empty&#34;)
        return

    if recompute_activation:
        self.calc_activation(xs=xs)
        xs = None

    if not self.activation_available:
        raise ValueError(
            &#34;Must have fitted the rule before calling &#39;eval&#39;, or use &#39;recompute_activation=True&#39; to recompute it&#34;
            &#34; from given xs&#34;
        )

    if xs is not None:
        activation = self.evaluate_activation(xs)
    else:
        activation = self._activation

    for attr in self.__class__.attributes_from_test_set:
        if attr == &#34;activation&#34;:
            raise ValueError(&#34;&#39;activation&#39; can not be specified in &#39;attributes_from_test_set&#39;&#34;)
        if not self.good and not force_if_not_good:
            setattr(self, f&#34;_{attr}&#34;, np.nan)
            continue
        launch_method(getattr(self, f&#34;calc_{attr}&#34;), y=y, xs=xs, activation=activation, **kwargs)
        if self.good:
            self.check_thresholds(attr)

    if self.good:
        self.check_thresholds()
    self._time_eval = time() - t0
    self._evaluated = True</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.evaluate_activation"><code class="name flex">
<span>def <span class="ident">evaluate_activation</span></span>(<span>self, xs: Union[pandas.core.frame.DataFrame, numpy.ndarray]) ‑> <a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a></span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns the activation vector from an array of features.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xs</code></strong> :&ensp;<code>Union[pd:DataFrame, np.ndarray]</code></dt>
<dd>The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
or pd:DataFrame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Activation</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_activation(self, xs: Union[pd.DataFrame, np.ndarray]) -&gt; Activation:
    &#34;&#34;&#34;Computes and returns the activation vector from an array of features.

    Parameters
    ----------
    xs: Union[pd:DataFrame, np.ndarray]
        The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
        or pd:DataFrame.

    Returns
    -------
    Activation
    &#34;&#34;&#34;
    arr = self._condition.evaluate(xs)
    # noinspection PyTypeChecker
    a = Activation(arr, to_file=self.__class__.LOCAL_ACTIVATION)
    return a</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, y: Union[numpy.ndarray, pandas.core.series.Series], xs: Union[pandas.core.frame.DataFrame, numpy.ndarray, ForwardRef(None)] = None, force_if_not_good: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes activation and attributes relevant to the train set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>Union[np.ndarray, pd.Series]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>xs</code></strong> :&ensp;<code>Union[pd.DataFrame, np.ndarray]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>force_if_not_good</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Additionnal keyword arguments for calc_<any_attribute></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(
    self,
    y: Union[np.ndarray, pd.Series],
    xs: Optional[Union[pd.DataFrame, np.ndarray]] = None,
    force_if_not_good: bool = False,
    **kwargs
):
    &#34;&#34;&#34;Computes activation and attributes relevant to the train set

    Parameters
    ----------
    y: Union[np.ndarray, pd.Series]
    xs: Union[pd.DataFrame, np.ndarray]
    force_if_not_good: bool
    kwargs: dict
        Additionnal keyword arguments for calc_&lt;any_attribute&gt;
    &#34;&#34;&#34;

    if &#34;method&#34; in kwargs:
        raise IndexError(&#34;Key &#39;method&#39; can not be given to &#39;fit&#39;&#34;)

    if self._fitted and xs is None:
        return

    t0 = time()

    def launch_method(method, **kw):
        expected_args = list(inspect.signature(method).parameters)
        if &#34;kwargs&#34; not in expected_args:
            kw = {item: kw[item] for item in kw if item in expected_args}
        method(**kw)

    if xs is not None and len(xs) == 0:
        logger.warning(&#34;Given xs is empty&#34;)
        return

    self.calc_activation(xs=xs)

    for attr in self.__class__.attributes_from_train_set:
        if attr == &#34;activation&#34;:
            raise ValueError(&#34;&#39;activation&#39; can not be specified in &#39;attributes_from_train_set&#39;&#34;)
        if not self.good and not force_if_not_good:
            setattr(self, f&#34;_{attr}&#34;, np.nan)
            continue
        launch_method(getattr(self, f&#34;calc_{attr}&#34;), y=y, xs=xs, **kwargs)
        if self.good:
            self.check_thresholds(attr)

    if self.good:
        self.check_thresholds()
    self.trigger_subattributes_computation()
    self._time_fit = time() - t0
    self._fitted = True</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.get_correlation"><code class="name flex">
<span>def <span class="ident">get_correlation</span></span>(<span>self, other: <a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the correlation between self and other
Correlation is the number of points in common between the two vectors divided by their length, times the product
of the rules' signs.
Both vectors must have the same length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_correlation(self, other: &#34;Rule&#34;) -&gt; float:
    &#34;&#34;&#34;Computes the correlation between self and other
    Correlation is the number of points in common between the two vectors divided by their length, times the product
    of the rules&#39; signs.
    Both vectors must have the same length.
    &#34;&#34;&#34;
    if not len(self) == len(other):
        raise ValueError(&#34;Both vectors must have the same length&#34;)

    sign = (self.prediction / abs(self.prediction)) * (other.prediction / abs(other.prediction))
    return self._activation.get_correlation(other._activation) * sign</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, xs: Union[pandas.core.frame.DataFrame, numpy.ndarray, ForwardRef(None)] = None) ‑> Union[numpy.ndarray, pandas.core.series.Series]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the prediction vector. If xs is not given, will use existing activation vector.
Will raise ValueError is xs is None and activation is not yet known.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xs</code></strong> :&ensp;<code>Optional[Union[pd.DataFrame, np.ndarray]]</code></dt>
<dd>The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
or pd:DataFrame. If not specified the rule's activation vector must have been computed already.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[np.ndarray, pd.Series]</code></dt>
<dd>np.nan where rule is not activated, rule's prediction where it is. If xs vas given and it was a dataframe,
return a pd.Series. Else, a np.ndarray.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, xs: Optional[Union[pd.DataFrame, np.ndarray]] = None) -&gt; Union[np.ndarray, pd.Series]:
    &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
    Will raise ValueError is xs is None and activation is not yet known.

    Parameters
    ----------
    xs: Optional[Union[pd.DataFrame, np.ndarray]]
        The features on which the check whether the rule is activated or not. Must be a 2-D np.ndarray
        or pd:DataFrame. If not specified the rule&#39;s activation vector must have been computed already.

    Returns
    -------
    Union[np.ndarray, pd.Series]
        np.nan where rule is not activated, rule&#39;s prediction where it is. If xs vas given and it was a dataframe,
        return a pd.Series. Else, a np.ndarray.
    &#34;&#34;&#34;
    t0 = time()
    if xs is not None:
        act = self.evaluate_activation(xs).raw
    elif self.activation is None:
        raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
    else:
        act = self.activation
    to_ret = np.array([np.nan] * len(act))
    if isinstance(self.prediction, str):
        if self.prediction == &#34;nan&#34;:
            raise ValueError(
                &#34;Prediction should not be the &#39;nan&#39; string, it will conflict with NaNs. Rename your class.&#34;
            )
        to_ret = to_ret.astype(str)
    to_ret[act == 1] = self.prediction
    if xs is not None and not isinstance(xs, np.ndarray):
        to_ret = xs.__class__(index=xs.index, data=to_ret).squeeze()  # So not to requier pandas explicitly
    self._time_predict = time() - t0
    return to_ret</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.set_thresholds"><code class="name flex">
<span>def <span class="ident">set_thresholds</span></span>(<span>self, path: Union[str, pathlib.Path, ForwardRef('TransparentPath')], show=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set thresholds for this rule only</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_thresholds(self, path: Union[str, Path, &#34;TransparentPath&#34;], show=False):
    &#34;&#34;&#34;Set thresholds for this rule only&#34;&#34;&#34;
    if path is None:
        self._thresholds.THRESHOLDS = None
    else:
        self._thresholds = Thresholds(path, show)</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.trigger_subattributes_computation"><code class="name flex">
<span>def <span class="ident">trigger_subattributes_computation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses getattr(self, attr) to trigger important attributes computation. Important attributes should be
Ruleset.rule_index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trigger_subattributes_computation(self):
    &#34;&#34;&#34;Uses getattr(self, attr) to trigger important attributes computation. Important attributes should be
    Ruleset.rule_index&#34;&#34;&#34;
    for attr in self.__class__.index:
        _ = getattr(self, attr)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ruleskit" href="index.html">ruleskit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ruleskit.rule.ClassificationRule" href="#ruleskit.rule.ClassificationRule">ClassificationRule</a></code></h4>
<ul class="">
<li><code><a title="ruleskit.rule.ClassificationRule.attributes_from_test_set" href="#ruleskit.rule.ClassificationRule.attributes_from_test_set">attributes_from_test_set</a></code></li>
<li><code><a title="ruleskit.rule.ClassificationRule.attributes_from_train_set" href="#ruleskit.rule.ClassificationRule.attributes_from_train_set">attributes_from_train_set</a></code></li>
<li><code><a title="ruleskit.rule.ClassificationRule.calc_criterion" href="#ruleskit.rule.ClassificationRule.calc_criterion">calc_criterion</a></code></li>
<li><code><a title="ruleskit.rule.ClassificationRule.calc_prediction" href="#ruleskit.rule.ClassificationRule.calc_prediction">calc_prediction</a></code></li>
<li><code><a title="ruleskit.rule.ClassificationRule.criterion" href="#ruleskit.rule.ClassificationRule.criterion">criterion</a></code></li>
<li><code><a title="ruleskit.rule.ClassificationRule.index" href="#ruleskit.rule.ClassificationRule.index">index</a></code></li>
<li><code><a title="ruleskit.rule.ClassificationRule.prediction" href="#ruleskit.rule.ClassificationRule.prediction">prediction</a></code></li>
<li><code><a title="ruleskit.rule.ClassificationRule.rule_index" href="#ruleskit.rule.ClassificationRule.rule_index">rule_index</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ruleskit.rule.RegressionRule" href="#ruleskit.rule.RegressionRule">RegressionRule</a></code></h4>
<ul class="">
<li><code><a title="ruleskit.rule.RegressionRule.attributes_from_test_set" href="#ruleskit.rule.RegressionRule.attributes_from_test_set">attributes_from_test_set</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.attributes_from_train_set" href="#ruleskit.rule.RegressionRule.attributes_from_train_set">attributes_from_train_set</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.calc_criterion" href="#ruleskit.rule.RegressionRule.calc_criterion">calc_criterion</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.calc_prediction" href="#ruleskit.rule.RegressionRule.calc_prediction">calc_prediction</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.calc_sign" href="#ruleskit.rule.RegressionRule.calc_sign">calc_sign</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.calc_std" href="#ruleskit.rule.RegressionRule.calc_std">calc_std</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.calc_zscore" href="#ruleskit.rule.RegressionRule.calc_zscore">calc_zscore</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.criterion" href="#ruleskit.rule.RegressionRule.criterion">criterion</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.index" href="#ruleskit.rule.RegressionRule.index">index</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.rule_index" href="#ruleskit.rule.RegressionRule.rule_index">rule_index</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.sign" href="#ruleskit.rule.RegressionRule.sign">sign</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.std" href="#ruleskit.rule.RegressionRule.std">std</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.time_calc_criterion" href="#ruleskit.rule.RegressionRule.time_calc_criterion">time_calc_criterion</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.time_calc_prediction" href="#ruleskit.rule.RegressionRule.time_calc_prediction">time_calc_prediction</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.time_calc_std" href="#ruleskit.rule.RegressionRule.time_calc_std">time_calc_std</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.zscore" href="#ruleskit.rule.RegressionRule.zscore">zscore</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></code></h4>
<ul class="">
<li><code><a title="ruleskit.rule.Rule.LOCAL_ACTIVATION" href="#ruleskit.rule.Rule.LOCAL_ACTIVATION">LOCAL_ACTIVATION</a></code></li>
<li><code><a title="ruleskit.rule.Rule.SET_THRESHOLDS" href="#ruleskit.rule.Rule.SET_THRESHOLDS">SET_THRESHOLDS</a></code></li>
<li><code><a title="ruleskit.rule.Rule.THRESHOLDS" href="#ruleskit.rule.Rule.THRESHOLDS">THRESHOLDS</a></code></li>
<li><code><a title="ruleskit.rule.Rule.activation" href="#ruleskit.rule.Rule.activation">activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.activation_available" href="#ruleskit.rule.Rule.activation_available">activation_available</a></code></li>
<li><code><a title="ruleskit.rule.Rule.attributes_from_test_set" href="#ruleskit.rule.Rule.attributes_from_test_set">attributes_from_test_set</a></code></li>
<li><code><a title="ruleskit.rule.Rule.attributes_from_train_set" href="#ruleskit.rule.Rule.attributes_from_train_set">attributes_from_train_set</a></code></li>
<li><code><a title="ruleskit.rule.Rule.bad_because" href="#ruleskit.rule.Rule.bad_because">bad_because</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_activation" href="#ruleskit.rule.Rule.calc_activation">calc_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_prediction_vector" href="#ruleskit.rule.Rule.calc_prediction_vector">calc_prediction_vector</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_test_set_size" href="#ruleskit.rule.Rule.calc_test_set_size">calc_test_set_size</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_train_set_size" href="#ruleskit.rule.Rule.calc_train_set_size">calc_train_set_size</a></code></li>
<li><code><a title="ruleskit.rule.Rule.check_thresholds" href="#ruleskit.rule.Rule.check_thresholds">check_thresholds</a></code></li>
<li><code><a title="ruleskit.rule.Rule.condition" href="#ruleskit.rule.Rule.condition">condition</a></code></li>
<li><code><a title="ruleskit.rule.Rule.condition_index" href="#ruleskit.rule.Rule.condition_index">condition_index</a></code></li>
<li><code><a title="ruleskit.rule.Rule.coverage" href="#ruleskit.rule.Rule.coverage">coverage</a></code></li>
<li><code><a title="ruleskit.rule.Rule.daughters" href="#ruleskit.rule.Rule.daughters">daughters</a></code></li>
<li><code><a title="ruleskit.rule.Rule.del_activation" href="#ruleskit.rule.Rule.del_activation">del_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.eval" href="#ruleskit.rule.Rule.eval">eval</a></code></li>
<li><code><a title="ruleskit.rule.Rule.evaluate_activation" href="#ruleskit.rule.Rule.evaluate_activation">evaluate_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.fit" href="#ruleskit.rule.Rule.fit">fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.fitted_if_has" href="#ruleskit.rule.Rule.fitted_if_has">fitted_if_has</a></code></li>
<li><code><a title="ruleskit.rule.Rule.get_correlation" href="#ruleskit.rule.Rule.get_correlation">get_correlation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.good" href="#ruleskit.rule.Rule.good">good</a></code></li>
<li><code><a title="ruleskit.rule.Rule.index" href="#ruleskit.rule.Rule.index">index</a></code></li>
<li><code><a title="ruleskit.rule.Rule.predict" href="#ruleskit.rule.Rule.predict">predict</a></code></li>
<li><code><a title="ruleskit.rule.Rule.prediction" href="#ruleskit.rule.Rule.prediction">prediction</a></code></li>
<li><code><a title="ruleskit.rule.Rule.rule_index" href="#ruleskit.rule.Rule.rule_index">rule_index</a></code></li>
<li><code><a title="ruleskit.rule.Rule.set_thresholds" href="#ruleskit.rule.Rule.set_thresholds">set_thresholds</a></code></li>
<li><code><a title="ruleskit.rule.Rule.test_set_size" href="#ruleskit.rule.Rule.test_set_size">test_set_size</a></code></li>
<li><code><a title="ruleskit.rule.Rule.thresholds" href="#ruleskit.rule.Rule.thresholds">thresholds</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_calc_activation" href="#ruleskit.rule.Rule.time_calc_activation">time_calc_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_fit" href="#ruleskit.rule.Rule.time_fit">time_fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_predict" href="#ruleskit.rule.Rule.time_predict">time_predict</a></code></li>
<li><code><a title="ruleskit.rule.Rule.to_hash" href="#ruleskit.rule.Rule.to_hash">to_hash</a></code></li>
<li><code><a title="ruleskit.rule.Rule.train_set_size" href="#ruleskit.rule.Rule.train_set_size">train_set_size</a></code></li>
<li><code><a title="ruleskit.rule.Rule.trigger_subattributes_computation" href="#ruleskit.rule.Rule.trigger_subattributes_computation">trigger_subattributes_computation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>